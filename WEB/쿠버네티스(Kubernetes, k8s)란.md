## 🚡 쿠버네티스(Kubernetes, k8s)란?

## 개념

[쿠버네티스 ](https://www.redhat.com/en/engage/introduction-enterprise-kubernetes-s-202003040257)(k8s, Kubernetes, 큐브, kube)는 컨테이너화된 애플리케이션을 배포, 관리, 확장할 때 수반되는 다수의 수동 프로세스를 자동화하는 [오픈소스](https://www.redhat.com/ko/topics/open-source/what-is-open-source) 컨테이너 오케스트레이션 플랫폼입니다.

[웨비나: 자체관리형(DIY) vs. 지원형(상용) 쿠버네티스](https://www.youtube.com/watch?v=vOpqEbyYT24)[Red Hat 리포트: 2023 글로벌 기술 전망](https://www.redhat.com/ko/resources/2023-global-tech-outlook-overview)[Red Hat 문의 방법](https://www.redhat.com/ko/contact)

## 쿠버네티스 클러스터(K8s Cluster)란?

Linux® 컨테이너를 실행하는 호스트 그룹을 함께 클러스터링할 수 있으며 쿠버네티스를 통해 이러한 클러스터를 쉽고 효율적으로 관리할 수 있습니다.

[쿠버네티스 클러스터](https://www.redhat.com/ko/topics/containers/what-is-a-kubernetes-cluster)는 온프레미스, [퍼블릭](https://www.redhat.com/ko/topics/cloud-computing/what-is-public-cloud), [프라이빗](https://www.redhat.com/ko/topics/cloud-computing/what-is-private-cloud) 또는 [하이브리드 클라우드](https://www.redhat.com/ko/topics/cloud-computing/what-is-hybrid-cloud) 전체로 호스트를 확장할 수 있습니다. 이러한 이유로 쿠버네티스는 [Apache Kafka](https://www.redhat.com/ko/topics/integration/what-is-apache-kafka)를 통한 실시간 데이터 스트리밍과 같이 신속한 확장을 요하는 [클라우드 네이티브 애플리케이션](https://www.redhat.com/ko/topics/cloud-native-apps)을 호스팅하는 데 이상적인 플랫폼입니다.



## 쿠버네티스 사용법

대부분의 기술과 마찬가지로 [쿠버네티스](https://www.youtube.com/watch?v=8VIyjYL6mLY) 기술은 알맞은 초보자 가이드를 필요로 합니다. 쿠버네티스를 쉽게 이해할 수 있도록 더 일반적인 용어로 분류하여 설명해보겠습니다.

**컨트롤 플레인:** 쿠버네티스 노드를 제어하는 프로세스의 컬렉션입니다. 여기에서 모든 태스크 할당이 시작됩니다.

**노드:** 컨트롤 플레인에서 할당된 요청 태스크를 수행하는 머신입니다.

**포드:** 단일 노드에 배포된 하나 이상의 컨테이너 그룹입니다. 포드에 있는 모든 컨테이너는 IP 주소, IPC, 호스트 이름, 기타 리소스를 공유합니다. 포드는 기본 컨테이너에서 네트워크와 스토리지를 추상화합니다. 이렇게 하면 클러스터에서 컨테이너를 더 쉽게 이동할 수 있습니다.

**복제 컨트롤러:** 이 컨트롤러는 클러스터에서 실행되어야 하는 동일한 포드 복사본의 개수를 제어합니다.

**서비스:** 포드에서 작업 정의를 분리합니다. 쿠버네티스 서비스 프록시는 클러스터에서 다른 위치로 이동된 경우나 교체된 경우에 상관없이 서비스 요청을 적절한 포드로 자동 수신합니다.

**Kubelet:** 이 서비스는 노드에서 실행되며 컨테이너 매니페스트를 읽고, 정의된 컨테이너가 시작되어 실행 중인지 확인합니다.

**kubectl:** 쿠버네티스의 커맨드 라인 구성 툴입니다.



## 쿠버네티스의 작동 방식

[![Kubernetes Cluster diagram](https://www.redhat.com/rhdc/managed-files/kubernetes_diagram-v3-770x717_0_0_v2.svg)](https://www.redhat.com/rhdc/managed-files/kubernetes_diagram-v3-770x717_0_0_v2.svg)

작동 중인 쿠버네티스 배포를 클러스터라고 합니다. 쿠버네티스 클러스터는 두 부분인 컨트롤 플레인과 컴퓨팅 머신(또는 노드)으로 시각화할 수 있습니다.

각 노드는 자체 [Linux®](https://www.redhat.com/ko/topics/linux) 환경이며 물리 또는 가상 머신일 수 있습니다. 각 노드는 컨테이너로 이루어진 포드(Pod)를 실행합니다.

컨트롤 플레인은 어느 애플리케이션을 실행하고 애플리케이션이 어느 컨테이너 이미지를 사용할지와 같이 클러스터를 원하는 상태로 유지 관리합니다. 컴퓨팅 머신은 애플리케이션과 워크로드를 실제로 실행합니다.

[쿠버네티스](https://www.youtube.com/watch?v=nOBs_VbyAmI)는 운영 체제(예: [Red Hat® Enterprise Linux®](https://www.redhat.com/ko/technologies/linux-platforms/enterprise-linux))를 기반으로 실행되며, 노드에서 실행되는 컨테이너의 포드와 상호 작용합니다.

쿠버네티스 컨트롤 플레인은 관리자(또는 DevOps팀)로부터 명령을 전달받고 해당 지침을 컴퓨팅 머신에 전달합니다.

이 전달은 여러 서비스와 연계하여 태스크에 가장 적합한 노드를 자동으로 결정합니다. 그런 다음 요청된 작업을 수행하기 위해 해당 노드에 리소스를 할당하고 포드를 할당합니다.

쿠버네티스 클러스터의 원하는 상태는 실행해야 할 애플리케이션이나 워크로드, 함께 사용하는 이미지, 사용 가능하도록 설정할 리소스, 기타 구성 세부 사항을 정의합니다.

인프라 측면에서 보면 컨테이너를 관리하는 방식에는 거의 변화가 없습니다. 컨테이너를 더 높은 수준에서 제어하므로 각각의 개별 컨테이너 또는 노드를 세분화하여 관리하지 않고도 더 효과적으로 제어할 수 있습니다.

작업에는 쿠버네티스 구성, 노드, 포드, 그 안의 컨테이너에 대한 정의가 포함됩니다. 쿠버네티스는 컨테이너 오케스트레이션을 처리합니다.

쿠버네티스를 원하는 곳에서 실행할 수 있습니다. 즉, 베어 메탈 서버, 가상 머신, 퍼블릭 클라우드 제공업체, 프라이빗 클라우드, 하이브리드 클라우드 환경 등에서 실행할 수 있습니다. 쿠버네티스의 주요 장점 중 하나는 다양한 종류의 인프라에서 작동한다는 것입니다.

[쿠버네티스 아키텍처란?](https://www.redhat.com/ko/topics/containers/kubernetes-architecture)

 

### 쿠버네티스 도커(Kubernetes Docker) 차이

[Docker](https://www.redhat.com/ko/topics/containers/what-is-docker)는 쿠버네티스가 오케스트레이션하는 컨테이너 런타임으로 사용할 수 있습니다. 쿠버네티스가 노드에 대해 포드를 예약하면 해당 노드의 kubelet이 지정된 컨테이너를 실행하도록 Docker에 명령합니다.

그런 다음 kubelet은 Docker에서 해당 컨테이너의 상태를 지속적으로 수집하고 해당 정보를 컨트롤 플레인에 집계합니다. Docker는 컨테이너를 해당 노드로 가져와서 해당 컨테이너를 시작하고 중지합니다.

Docker와 함께 쿠버네티스를 사용할 때 차이가 있다면 관리자가 모든 컨테이너의 모든 노드에서 작업을 직접 수행하는 것이 아니라 자동화된 시스템이 이러한 작업을 Docker에 요청한다는 것입니다.



<br>

<br>

#### 참고링크: [쿠버네티스(Kubernetes, k8s)란? 기본 개념, 사용법, 차이점 (redhat.com)](https://www.redhat.com/ko/topics/containers/what-is-kubernetes)

<br>



## 쿠버네티스란 무엇인가?

이 페이지에서는 쿠버네티스 개요를 설명한다.

쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성이 있고, 확장가능한 오픈소스 플랫폼이다. 쿠버네티스는 선언적 구성과 자동화를 모두 용이하게 해준다. 쿠버네티스는 크고, 빠르게 성장하는 생태계를 가지고 있다. 쿠버네티스 서비스, 기술 지원 및 도구는 어디서나 쉽게 이용할 수 있다.

쿠버네티스란 명칭은 키잡이(helmsman)나 파일럿을 뜻하는 그리스어에서 유래했다. K8s라는 표기는 "K"와 "s"와 그 사이에 있는 8글자를 나타내는 약식 표기이다. 구글이 2014년에 쿠버네티스 프로젝트를 오픈소스화했다. 쿠버네티스는 프로덕션 워크로드를 대규모로 운영하는 [15년 이상의 구글 경험](https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/)과 커뮤니티의 최고의 아이디어와 적용 사례가 결합되어 있다.

## 여정 돌아보기

시간이 지나면서 쿠버네티스가 왜 유용하게 되었는지 살펴보자.

![배포 혁명](https://d33wubrfki0l68.cloudfront.net/26a177ede4d7b032362289c6fccd448fc4a91174/eb693/images/docs/container_evolution.svg)

**전통적인 배포 시대:** 초기 조직은 애플리케이션을 물리 서버에서 실행했었다. 한 물리 서버에서 여러 애플리케이션의 리소스 한계를 정의할 방법이 없었기에, 리소스 할당의 문제가 발생했다. 예를 들어 물리 서버 하나에서 여러 애플리케이션을 실행하면, 리소스 전부를 차지하는 애플리케이션 인스턴스가 있을 수 있고, 결과적으로는 다른 애플리케이션의 성능이 저하될 수 있었다. 이에 대한 해결책으로 서로 다른 여러 물리 서버에서 각 애플리케이션을 실행할 수도 있다. 그러나 이는 리소스가 충분히 활용되지 않는다는 점에서 확장 가능하지 않았으며, 조직이 많은 물리 서버를 유지하는 데에 높은 비용이 들었다.

**가상화된 배포 시대:** 그 해결책으로 가상화가 도입되었다. 이는 단일 물리 서버의 CPU에서 여러 가상 시스템 (VM)을 실행할 수 있게 한다. 가상화를 사용하면 VM간에 애플리케이션을 격리하고 애플리케이션의 정보를 다른 애플리케이션에서 자유롭게 액세스할 수 없으므로, 일정 수준의 보안성을 제공할 수 있다.

가상화를 사용하면 물리 서버에서 리소스를 보다 효율적으로 활용할 수 있으며, 쉽게 애플리케이션을 추가하거나 업데이트할 수 있고 하드웨어 비용을 절감할 수 있어 더 나은 확장성을 제공한다. 가상화를 통해 일련의 물리 리소스를 폐기 가능한(disposable) 가상 머신으로 구성된 클러스터로 만들 수 있다.

각 VM은 가상화된 하드웨어 상에서 자체 운영체제를 포함한 모든 구성 요소를 실행하는 하나의 완전한 머신이다.

**컨테이너 개발 시대:** 컨테이너는 VM과 유사하지만 격리 속성을 완화하여 애플리케이션 간에 운영체제(OS)를 공유한다. 그러므로 컨테이너는 가볍다고 여겨진다. VM과 마찬가지로 컨테이너에는 자체 파일 시스템, CPU 점유율, 메모리, 프로세스 공간 등이 있다. 기본 인프라와의 종속성을 끊었기 때문에, 클라우드나 OS 배포본에 모두 이식할 수 있다.

컨테이너는 다음과 같은 추가적인 혜택을 제공하기 때문에 유명해졌다.

- 기민한 애플리케이션 생성과 배포: VM 이미지를 사용하는 것에 비해 컨테이너 이미지 생성이 보다 쉽고 효율적이다.
- 지속적인 개발, 통합 및 배포: 안정적이고 주기적으로 컨테이너 이미지를 빌드해서 배포할 수 있고 (이미지의 불변성 덕에) 빠르고 효율적으로 롤백할 수 있다.
- 개발과 운영의 관심사 분리: 배포 시점이 아닌 빌드/릴리스 시점에 애플리케이션 컨테이너 이미지를 만들기 때문에, 애플리케이션이 인프라스트럭처에서 분리된다.
- 가시성(observability): OS 수준의 정보와 메트릭에 머무르지 않고, 애플리케이션의 헬스와 그 밖의 시그널을 볼 수 있다.
- 개발, 테스팅 및 운영 환경에 걸친 일관성: 랩탑에서도 클라우드에서와 동일하게 구동된다.
- 클라우드 및 OS 배포판 간 이식성: Ubuntu, RHEL, CoreOS, 온-프레미스, 주요 퍼블릭 클라우드와 어디에서든 구동된다.
- 애플리케이션 중심 관리: 가상 하드웨어 상에서 OS를 실행하는 수준에서 논리적인 리소스를 사용하는 OS 상에서 애플리케이션을 실행하는 수준으로 추상화 수준이 높아진다.
- 느슨하게 커플되고, 분산되고, 유연하며, 자유로운 마이크로서비스: 애플리케이션은 단일 목적의 머신에서 모놀리식 스택으로 구동되지 않고 보다 작고 독립적인 단위로 쪼개져서 동적으로 배포되고 관리될 수 있다.
  - 리소스 격리: 애플리케이션 성능을 예측할 수 있다.
  - 리소스 사용량: 고효율 고집적.

## 쿠버네티스가 왜 필요하고 무엇을 할 수 있나

컨테이너는 애플리케이션을 포장하고 실행하는 좋은 방법이다. 프로덕션 환경에서는 애플리케이션을 실행하는 컨테이너를 관리하고 가동 중지 시간이 없는지 확인해야 한다. 예를 들어 컨테이너가 다운되면 다른 컨테이너를 다시 시작해야 한다. 이 문제를 시스템에 의해 처리한다면 더 쉽지 않을까?

그것이 쿠버네티스가 필요한 이유이다! 쿠버네티스는 분산 시스템을 탄력적으로 실행하기 위한 프레임 워크를 제공한다. 애플리케이션의 확장과 장애 조치를 처리하고, 배포 패턴 등을 제공한다. 예를 들어, 쿠버네티스는 시스템의 카나리아 배포를 쉽게 관리할 수 있다.

쿠버네티스는 다음을 제공한다.

- **서비스 디스커버리와 로드 밸런싱** 쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있다. 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있다.
- **스토리지 오케스트레이션** 쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재할 수 있다
- **자동화된 롤아웃과 롤백** 쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다. 예를 들어 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있다.
- **자동화된 빈 패킹(bin packing)** 컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공한다. 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시한다. 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해준다.
- **자동화된 복구(self-healing)** 쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, '사용자 정의 상태 검사'에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않는다.
- **시크릿과 구성 관리** 쿠버네티스를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리할 수 있다. 컨테이너 이미지를 재구성하지 않고 스택 구성에 시크릿을 노출하지 않고도 시크릿 및 애플리케이션 구성을 배포 및 업데이트할 수 있다.



<br>

<br>

#### 참고링크: [[쿠버네티스란 무엇인가? | Kubernetes](https://kubernetes.io/ko/docs/concepts/overview/)](https://www.redhat.com/ko/topics/containers/what-is-kubernetes)

<br>