## 🧩 해싱 알고리즘

![img](https://resources.appsealing.com/4-svc/wp-content/uploads/2021/04/27130230/hashing-algorithm-1.png)

우리는 다양한 파일을 공유하고, 다양한 툴을 쓰기 위해 각기 다른 소스에서 수없이 많은 로그인 시도를 하며 원격 근무를 합니다. 이러한 활동은 종종 불가피하고 사업이 제대로 굴러가기 위해선 필수적입니다. 자격 증명에 대해 먼저 이야기를 해보겠습니다. 많은 기관에서 사용자 ID와 비밀번호가 데이터베이스 테이블에 보관합니다. 로그인 시도를 하면 시스템이 사용자 ID를 확인해서 사용자가 입력한 암호와 테이블 내 있는 암호가 일치하는지 비교합니다. 가장 기본적인 암호 보관 포맷은 “암호화되지 않아 읽을 수 있는 데이터”로 저장되는 평문입니다. 그러나 이 수준의 보안은 사실상 해커가 쉽게 해킹할 수 있는 디지털 종이 조각 위에 자격 증명을 써 놓은 거나 마찬가지이기 때문에 딱히 논할 가치가 없습니다. 그러니 이런 시스템이 얼마나 취약한지 아시겠죠! 해결책은 무엇일까요?

# **해싱 알고리즘**

암호 기법의 핵심적인 부분인 해싱 알고리즘 설명을 시작하겠습니다. 해싱 알고리즘은 “데이터를 최종 사용자가 원문을 추정하기 힘든 더 작고, 뒤섞인 조각으로 나누는 것”을 의미합니다. 해시 함수는 특정 입력 데이터에서 고정 길이값 또는 해시값을 생성하는 알고리즘입니다. 이는 평문을 암호화된 텍스트로 변환하고 해독을 통해 암호화된 텍스트를 원래 평문으로 바꾸는 암호화와는 다릅니다. 해싱 알고리즘의 경우, 암호화 해시 함수로 평문을 해시 처리한 텍스트로 바꿔, 해커가 알아보기 힘들게 합니다. (해시 길이는 160~ 512비트가 좋습니다) 그러나 이는 원문을 다시 만들어낼 수 있는 방법을 제공하지 않습니다.

![img](https://resources.appsealing.com/4-svc/wp-content/uploads/2021/04/27124415/image1.png)

그러므로 암호 보안을 확보하고자 한다면, 암호를 해시 처리한 후 사용자 ID와 함께 짝을 지어 데이터베이스 테이블에 보관해줍니다. 로그인 시, 입력한 암호는 해시 처리되어 데이터베이스 테이블의 해시 처리된 입력값과 비교됩니다. 두 값이 일치한다면, 짜잔! 사용자는 작업을 계속할 수 있습니다.

해시태그는 암호 저장, 무결성 검증, 디지털 서명, 메시지 인증 코드에 활용될 수 있습니다. 해시태그는 또한 핑거프린팅, 파일 전송, 검사합 등에 유용하게 쓰입니다.

## 이상적인 암호화 해시 함수란?

해시 함수가 사용하기 이상적인 이유로 몇 가지 핵심 요소를 들 수 있습니다.

### **해시 함수는 단방향 함수로 작용한다**

해싱 알고리즘 처리를 거친 후에는 원본 텍스트로 복구하는 게 불가능합니다. 그러므로 특정 결과값을 얻었을 때, 이상적인 해시 함수는 해당 결과값을 도출한 초기 투입값을 절대 얻지 못하게 합니다. 예를 들어 6을 2로 나누면 결과값은 3입니다. 그러나 9도 3으로 나눠집니다. 그러나 결과값 ‘3’만으로는 절대 초기 숫자 2개를 알아낼 방법이 없습니다. 

### **해시 함수에서는 눈사태 효과가 매우 잘 나타난다**

특정 입력값은 특정 출력값을 산출하지만, 입력값에 매우 작은 변화만 줘도(해당 변화가 매우 사소한 것일지라도) 이는 꽤나 극단적인 출력값의 변화로 이어집니다. 다음과 같이 예를 들어보겠습니다.

입력값: App1sealing583
해시: 5420d1938buif7686dedsf9560bb5087d24676de5f83b7cb4c3b96bf46ec388b

입력값: App2sealing583
해시: 4ic79ff6a81da0b5fc63989d6b6db7dbf1264228052d2da70baqsf7f82961rt6

### **해시 함수는 매우 빨리 연산할 수 있다**

해시 함수가 강력하게 구축되어 있다면 어떤 입력 데이터라도 몇 초만에 결과값을 얻을 수 있습니다.

### **해시 함수 결과값은 충돌이 일어나지 않는다**

두 입력 매개변수의 결과값은 절대 같지 않습니다.(해시 함수 출력값의 길이를 보면 무슨 말인지 아실 겁니다)

### **해시 함수는 결정론적이다**

한 입력 매개변수의 출력값은 시점과 사용 횟수에 상관 없이 항상 같습니다. 이는 특히 여러 사람이 서로 다른 지점에서 동시에 인증을 해야할 때 특히 유용합니다.

## 해시 알고리즘이 어떻게 작동하는가? 해시 알고리즘의 실제 활용

이 글의 초입에서 암호와 자격 증명을 논했습니다. 이제 파일 전송을 다뤄봅시다. 누군가(X라고 합시다) 다른 사람(Y라고 합시다)에게 파일을 전송하고 싶은 경우 해시 알고리즘을 사용하지 않는다면, X가 콘텐츠나 수취인을 확인할 수 있는 유일한 방법은 Y를 직접 확인하는 것입니다. 그러나 이는 매우 번거로우며, 이 부산하고 빠르게 돌아가면서도 매우 불안한 세상에서는 의미가 없는 행위입니다. 게다가 만약 보내는 내용이 길다면, 파일의 용량이 무겁거나 이와 관련된 다양한 종류와 포맷으로 된 여러 첨부파일이 메일에 포함되어, 결국엔 처리하는 데 며칠씩 걸릴 겁니다.
하지만 해싱 알고리즘을 사용한다면 X는 특정 파일에 대해 검사합(전송 중 오류를 감지하는 타 블록에서 유래한 작은 크기의 디지털 데이터 블록)을 생성할 수 있습니다. Y가 이 파일과 검사합을 받으면 그는 같은 해싱 알고리즘을 수취한 파일에 활용합니다. 이로써 맞는 파일이 올바른 발송인으로부터 올바른 수취인에게 보내졌다는 걸 보장할 수 있습니다.

## 해싱 알고리즘의 종류

### MD5 (MD는 메시지 다이제스트의 약자)

가장 흔하게 사용되지만 제일 안전하지 않은 알고리즘 중 하나이기도 합니다. 해당 방식을 사용해 암호가 특정 패턴으로 변환될 경우, 그냥 해시값을 구글링해 원본 값을 구하는 건 매우 쉽습니다. 그러므로 이는 사용하지 않는 것이 가장 좋으며, 사실 더 이상 사용하기 부적절하다고 여겨집니다.

예시:

입력값: An example of MD5
출력값: 6c30eeb06ce8eb66b7a65191272b9743

### **SHA (안전한 해시 알고리즘) 계열 알고리즘**

1993년에 도입된 SHA-0는 수없이 많이 노출되었습니다. 비록 SHA-1가 보안 소켓 레이어(SSL) 보안용으로 사용된 조금 더 개선된 버전이긴 하나, 이 또한 수많은 공격의 대상이었습니다. SHA-2가 더 복잡하기 때문에 현재 SHA-2 사용이 권장되고 있습니다. SHA-3는 보안을 매우 중요하게 생각하는 회사들이 사용합니다.

예시: 

입력값: An example of SHA-1
출력값: 482ae821c8245e9545e3275cfec2e2657ccab6fb 

### **Whirlpool (월풀)**

월풀은 512 비트 해시 함수로 고급 암호화 기준(AES)에서 비롯되었습니다.

예시: 

입력값: An example of Whirlpool
출력값: 42fefc20dd412b5ad776271d1008ca65d1503a5acd384f3b4e3c8793ded11a0c3d853d721c6d23c37deeecc9b98765575c806099cec4a61b402b65b7a271bfd7

### **RIPEMD 계열 알고리즘**

RACE 무결성 초기 평가 메시지 다이제스트의 약자로, 1990년대 중반에 개발되었습니다. RIPEMD-160, RIPEMD-256 및 RIPEMD-320와 같이 다양한 버전이 있습니다. 출력값 길이가 이후 버전에서 계속 길어지므로, 보안성 또한 증가합니다.

예시:

입력값: An example of RIPEMD-160
출력값: 033432770126267d6640cb35b1d7e1e75a78e7e5

### **CRC32:**

순환 중복 코드는 확산성으로 흔히 잘 알려져 있습니다. 이는 또한 훨씬 빨라 원만한 파일 전송 및 유효성 검사가 가능합니다.

예시:

입력값: An example of CRC32
출력값: 5c8e1a03

## **해싱 알고리즘 보안 한계점**

해싱 알고리즘이 안전하기는 하나 해킹 공격에 면역이 있는 것은 아닙니다. 때로 해커는 인증에 사용 가능한 입력값을 해시 함수에 입력하기도 합니다. 일치하는 값을 찾을 때까지 무차별 대입 공격으로 다수의 로그인 시도를 할 수도 있습니다.

언제나 특정 입력값 하나가 특정 출력값 하나를 도출하기 때문에, ‘123456’ 같이 흔하게 사용되는 암호는 해커가 해시하여 허가되지 않은 출입권을 얻기 더 쉬울 것입니다. 또 여러 사용자가 같은 암호를 사용하고 있다면, 해커에게는 정말 기쁜 일이겠지요.

암호를 풀기 위해 미리 연산한 해시 체인으로 이루어진 대규모 데이터베이스를 해커가 사용하는 레인보우 테이블 공격이란 방식도 흔하게 이뤄집니다. 세상에서 제일 흔하게 사용되는 암호인 123456을 예로 들어보겠습니다. MD5 해싱 함수를 사용했다고 가정해봅시다. 레인보우 테이블 공격은 다음과 같이 작동합니다.

1. 암호(123456)을 MD5 해시 함수에 입력하면 e10adc3949ba59abbe56e057f20f883e 값이 나옵니다.
2. 해시된 위의 값 중 일부분(e10adc)을 입력해 재해시된 값 96bf38d01b84aa16cf2bb9f55c61ac85을 구합니다.
3. 초기 평문부터 시작해 최종 해시된 텍스트까지 체인 형태로 된 충분히 많은 해시를 얻을 때까지 위 과정을 반복합니다.
4. 이 모든 해시를 테이블에 저장합니다.
5. 일치하는 값이 나올 때까지 리스트를 계속 돌립니다.

이런 시도에 대응하고자, 암호 해독을 더 어렵게 만들기 위해 해시된 값에 복잡성을 더하는 솔트 기법이 활용됩니다. 솔트 기법은 무작위 데이터를 해시 함수 입력값에 더하여 더 복잡한 출력값을 생성합니다. 레인보우 테이블은 주로 솔트 기법을 적용하지 않은 해시값에 작용하기 때문에, 솔트 기법 적용은 추가적인 보안성을 더해줍니다

애플리케이션 공격을 실시간으로 감지하는 [런타임 애플리케이션 자가 보호(RASP)](https://www.appsealing.com/rasp-security/)는 공격을 대비할 수 있는 좋은 사례입니다. 사람이 적게 관여하면서도 애플리케이션의 맥락적 행동을 스마트하게 분석하는 RASP는 더 나은 보안을 보장합니다. 수상한 행동이 감지되면 RASP는 세션을 종료하거나 사용자에게 추가적인 행동을 취하도록 관련 알람을 보냅니다. 또한 RASP는 애플리케이션의 매개변수만 감시하지 애플리케이션 내에서 어떤 작용이 일어나고 있는지는 알지 못하는 방화벽에 비해 이점이 있습니다. 

## 최종 의견

비록 보안성을 추가한 해싱 알고리즘의 새로운 버전이 시장에 도입되며 SHA-2가 좋은 선택지로 보입니다만, 최신 해싱 알고리즘 기술을 인지하고 있는 게 언제나 더 낫습니다. 

자격 증명과 파일/메시지 전송이 전 세계적으로 계속되는 사업 연속성 측면에서 해싱 알고리즘은 충분한 보안성을 제공합니다. 

코딩 없이 자바 스크립트 코드를 리버스 엔지니어링과 위변조 공격으로부터 지키고 싶으시다면, 아래 링크를 클릭해 [AppSealing](https://www.appsealing.com/)에 대해 알아보시고 가입하셔서 무료 체험판을 사용해보시기 바랍니다.





<br>

<br>

#### 참고링크: [해시 함수 이해를 돕기 위한 깊이 있는 가이드 (appsealing.com)](https://www.appsealing.com/kr/해싱-알고리즘/)

<br>